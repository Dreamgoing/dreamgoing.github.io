<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>分布式系统6.824-入门介绍</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857143; overflow-x: hidden; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; background-position: inherit inherit; background-repeat: inherit inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; padding-bottom: 70px; overflow-x: visible; }
.first-line-indent #write div, .first-line-indent #write li, .first-line-indent #write p { text-indent: 2em; }
.first-line-indent #write div :not(p):not(div), .first-line-indent #write div.md-htmlblock-container, .first-line-indent #write p *, .first-line-indent pre { text-indent: 0px; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
@media screen and (max-width: 500px) { 
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write > blockquote:first-child, #write > div:first-child, #write > figure:first-child, #write > ol:first-child, #write > p:first-child, #write > pre:first-child, #write > ul:first-child { margin-top: 30px; }
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 80px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; position: relative !important; background-position: inherit inherit; background-repeat: inherit inherit; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; background-position: 0px 0px; background-repeat: initial initial; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print { 
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid-page; break-before: avoid-page; }
  #write { margin-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 1cm; padding-right: 1cm; padding-bottom: 0px; break-after: avoid-page; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; overflow-x: hidden; background-position: initial initial; background-repeat: initial initial; }
p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; text-align: center; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background-color: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; background-position: initial initial; background-repeat: initial initial; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
a.md-print-anchor { white-space: pre !important; border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; text-shadow: initial !important; background-position: 0px 0px !important; background-repeat: initial initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom-width: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


html {
	font-size: 19px;
}

html, body {
	margin: auto;
	background: #fefefe;
}
body {
	font-family: "Vollkorn", Palatino, Times;
	color: #333;
	line-height: 1.4;
	text-align: justify;
}
#write {
	max-width: 960px;
	margin: 0 auto;
	margin-bottom: 2em;
	line-height: 1.53;
}

#write>h2:first-child,
#write>h3:first-child,
#write>h4:first-child,
#write>p:first-child{
	margin-top: 1.2em;
}

/* Typography
-------------------------------------------------------- */

#write>h1:first-child,
h1 {
	margin-top: 1.6em;
	font-weight: normal;
}

h1 {
	font-size:3em;
}

h2 {
	margin-top:2em;
	font-weight: normal;
}

h3 {
	font-weight: normal;
	font-style: italic;
	margin-top: 3em;
}

h1, 
h2, 
h3{
	text-align: center;
}

h2:after{
	border-bottom: 1px solid #2f2f2f;
    content: '';
    width: 100px;
    display: block;
    margin: 0 auto;
    height: 1px;
}

h1+h2, h2+h3 {
	margin-top: 0.83em;
}

p,
.mathjax-block {
	margin-top: 0;
	-webkit-hypens: auto;
	-moz-hypens: auto;
	hyphens: auto;
}
ul {
	list-style: square;
	padding-left: 1.2em;
}
ol {
	padding-left: 1.2em;
}
blockquote {
	margin-left: 1em;
	padding-left: 1em;
	border-left: 1px solid #ddd;
}
code,
pre {
	font-family: "Consolas", "Menlo", "Monaco", monospace, serif;
	font-size: .9em;
	background: white;
}
.md-fences{
	margin-left: 1em;
	padding-left: 1em;
	border: 1px solid #ddd;
	padding-bottom: 8px;
	padding-top: 6px;
	margin-bottom: 1.5em;
}

a {
	color: #2484c1;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
a img {
	border: none;
}
h1 a,
h1 a:hover {
	color: #333;
	text-decoration: none;
}
hr {
	color: #ddd;
	height: 1px;
	margin: 2em 0;
	border-top: solid 1px #ddd;
	border-bottom: none;
	border-left: 0;
	border-right: 0;
}
.ty-table-edit {
	background: #ededed;
    padding-top: 4px;
}
table {
	margin-bottom: 1.333333rem
}
table th,
table td {
	padding: 8px;
	line-height: 1.333333rem;
	vertical-align: top;
	border-top: 1px solid #ddd
}
table th {
	font-weight: bold
}
table thead th {
	vertical-align: bottom
}
table caption+thead tr:first-child th,
table caption+thead tr:first-child td,
table colgroup+thead tr:first-child th,
table colgroup+thead tr:first-child td,
table thead:first-child tr:first-child th,
table thead:first-child tr:first-child td {
	border-top: 0
}
table tbody+tbody {
	border-top: 2px solid #ddd
}

.task-list{
	padding:0;
}

.md-task-list-item {
	padding-left: 1.6rem;
}

.md-task-list-item > input:before {
	content: '\221A';
	display: inline-block;
	width: 1.33333333rem;
  	height: 1.6rem;
	vertical-align: middle;
	text-align: center;
	color: #ddd;
	background-color: #fefefe;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before{
	color: inherit;
}
.md-tag {
	color: inherit;
	font: inherit;
}
#write pre.md-meta-block {
	min-height: 35px;
	padding: 0.5em 1em;
}
#write pre.md-meta-block {
	white-space: pre;
	background: #f8f8f8;
	border: 0px;
	color: #999;
	
	width: 100vw;
	max-width: calc(100% + 60px);
	margin-left: -30px;
	border-left: 30px #f8f8f8 solid;
	border-right: 30px #f8f8f8 solid;

	margin-bottom: 2em;
	margin-top: -1.3333333333333rem;
	padding-top: 26px;
	padding-bottom: 10px;
	line-height: 1.8em;
	font-size: 0.9em;
	font-size: 0.76em;
	padding-left: 0;
}
.md-img-error.md-image>.md-meta{
	vertical-align: bottom;
}
#write>h5.md-focus:before {
	top: 2px;
}

.md-toc {
	margin-top: 40px;
}

.md-toc-content {
	padding-bottom: 20px;
}

.outline-expander:before {
	color: inherit;
	font-size: 14px;
	top: auto;
	content: "\f0da";
	font-family: FontAwesome;
}

.outline-expander:hover:before,
.outline-item-open>.outline-item>.outline-expander:before {
  	content: "\f0d7";
}

/** source code mode */
#typora-source {
	font-family: Courier, monospace;
    color: #6A6A6A;
}

.html-for-mac #typora-sidebar {
    -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
}

.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property,
.CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
	color: #428bca;
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
	color: #777777;
}

.typora-node .file-list-item-parent-loc, 
.typora-node .file-list-item-time, 
.typora-node .file-list-item-summary {
	font-family: arial, sans-serif;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: calc(1rem - 12px);
}

.md-mathjax-midline {
	background: #fafafa;
}

.md-fences .code-tooltip {
	bottom: -2em !important;
}

 .typora-export p, .typora-export .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export' >
<div  id='write'  class = 'is-mac'><h1><a name='header-n0' class='md-header-anchor '></a>分布式系统6.824-入门介绍(一)</h1><h2><a name='header-n2' class='md-header-anchor '></a>MapReduce</h2><blockquote><p>MapReduce 是一种编程范式, 是由函数式编程模型中的<code>map</code>和<code>reduce</code>演化而来的.</p></blockquote><h3><a name='header-n5' class='md-header-anchor '></a>概述</h3><p>MapReduce: 使用<code>Map</code>函数将<code>key/value</code>转化成中间结果的<code>key/value</code>, <code>reduce</code>函数合并所有的中间结果并且与相关的key关联.</p><p>函数式的程序可以自动的并且并行的运行在大规模集群上面. 实时运行的整个系统关注于输入数据, 调度任务执行, 处理错误, 管理内部所必须的网络通信等.</p><h3><a name='header-n8' class='md-header-anchor '></a>编程模型</h3><p><code>Map</code>: 输入<code>pair</code>, <code>kefxiy/value</code>. 输出中间表示<code>intermediate key/value</code>
<code>Reduce</code>: 输入中间表示<code>intermediate key/value</code>, 输出对应的结果. 输入通常是迭代器, 因为内存中无法存放海量的数据.  </p><p><strong>常见例子:</strong></p><ul><li>统计词频/统计URL: <code>map</code>: 对每个单词生成一对<code>(key, 1)</code> <code>reduce</code>: 将每一对<code>(key, 1)</code>合并起来</li><li>分布式<code>Grep</code>: <code>map</code>: 执行grep, <code>reduce</code>: 仅仅将每一项<code>map</code>的结果进行复制</li><li>翻转<code>web</code> 链接图: <code>map</code>:输入<code>&lt;source, target&gt;</code>输出每一个<code>&lt;target, source&gt;</code>. <code>reduce</code>: 输出<code>&lt;target, list(source)&gt;</code></li><li>倒排索引: <code>map</code>:输出<code>&lt;word, document ID&gt;</code>, <code>reduce</code>函数将所有<code>&lt;word, document ID&gt;</code>聚合成<code>&lt;word, list(document ID)&gt;</code>这样就可跟踪单词在全文中的位置</li><li>分布式排序: </li></ul><h3><a name='header-n22' class='md-header-anchor '></a>运行概述</h3><p><img src='./image/map_reduce.png' alt='' referrerPolicy='no-referrer' /></p><ol start='' ><li><code>MapReduce</code>库在用户程序中首先分割<code>input files</code>为M块, 每块为典型的16MB~64MB(通过可选项确定), 然后启动许多<code>forked</code>的程序在集群机器上.</li><li>这些<code>forked</code>的程序其中有一个比较特殊为<code>Master</code>程序. 其余程序为<code>Worker</code>程序.<code>Master</code>程序向<code>Worker</code>分配任务. <code>Master</code>会选择空闲的<code>Worker</code>提交一个<code>map</code>任务或者<code>Reduce</code>任务</li><li>被赋予<code>Map</code>任务的的<code>Worker</code>会读取<code>input files</code>的内容, 到<code>intermediate key/value</code>并且存在内存中</li><li>内存的中的<code>key/value</code>会被定期的写入本地磁盘中, 并且被<code>partitioning function</code>划分到不同的区域. 这些在本地磁盘中的<code>pair</code>的位置会传回到<code>Master</code>,以便后续的<code>Reduece</code>函数使用.</li><li>当一个<code>Reduce Worker</code>获取<code>Master</code>通知的之前<code>intermediate key/value</code>在磁盘中的位置时. <code>Reduce Worker</code>将会通过远程过程调用读取数据. 读取结束之后, 将会根据<code>intermediate keys</code>对数据进行排序. 这样以便所有的keys聚集到一起. 如果数据太大无法放进内存, 则使用外部排序.</li><li><code>Reduce Worker</code>对于每一个不同的<code>intermediate key</code>进行计算, 即将<code>key</code>和<code>intermediate values</code>传入<code>Reduce Function</code>. <code>Reduce Funciton</code>的结果将会被添加到最终的结果文件中.</li><li>当所有<code>Map</code>和<code>Reduce</code>的任务完成之后, <code>Master</code>将会唤醒用户进程. <code>MapReduce</code>的调用返回.</li></ol><h3><a name='header-n39' class='md-header-anchor '></a><code>Master</code>数据结构</h3><p><code>Master</code> 保持着许多数据结构. 对于每个<code>Map</code>和<code>Reduce</code>的任务, 会保留其的状态(空闲, 在进行中, 完成), 和其ID.</p><p><code>Master</code>是从<code>Map task</code>到<code>intermediate file</code>到<code>Reduce task</code>的通道. </p><h3><a name='header-n42' class='md-header-anchor '></a>容错性</h3><p>由于<code>MapReduce</code>是被设计去处理大规模的数据, 运行在大规模分布式集群上面. 所以<code>MapReduce</code>需要保持高的容错</p><h4><a name='header-n44' class='md-header-anchor '></a><code>Worker Failure</code></h4><p><code>Master</code>会定期的<code>ping</code>每个<code>Worker</code>, 如果没有在规定的时间内回应, <code>Master</code>将会把该<code>Worker</code>标记为<code>failed</code>. 所有的<code>map task</code>被<code>Woker</code>完成, <code>Master</code>将会把<code>Worker</code>的状态标记为空闲(idle), 这样该<code>Worker</code>可以重新被调度. </p><p><code>map task</code>在失败的情况下, 需要去重新执行, 因为输出保存在本地磁盘(私有临时文件), 不是全局共享的, 是该机器独有的.</p><p><code>reduce task</code>在失败的情况下, 可以不必去重新执行, 输出保存在GFS(global file system)中, 失败之后, 可以重新调度任务, 去执行, 不必在失败的机器上面继续执行.</p><p><code>map task</code>可以重复执行, 只有其中的一个<code>task</code>会被告知给<code>Reduce Worker</code>, 其余的都会被认为失败了. </p><p><code>reduce task</code>如果重复执行了, 多个重复的任务都会写在GFS上面! </p><h4><a name='header-n50' class='md-header-anchor '></a><code>Master Failure</code></h4><p><code>Master</code>会定期的向<code>Master</code>的数据结构中写<code>checkpoints</code>, 如果<code>Master</code>挂了, 则会根据上次的<code>checkpoints</code>重新<code>fork</code>一个<code>Master</code>.</p><h3><a name='header-n52' class='md-header-anchor '></a><code>Master Locality</code>文件定位</h3><p>网络带宽在计算环境中是一种比较稀缺的资源. 通过用<code>GFS</code>来管理存储在本地的<code>input data</code>来节省网络带宽资源的消耗. <code>GFS</code>将每一个文件切分成大小为64MB的块, 并且存储三份备份在不同的机器上. <code>Master</code>获取<code>input files</code>存储的具体位置信息, 并且在包含相关<code>input files</code>的副本的机器上面执行<code>map task</code>. 当<code>map task</code>失败之后, 则将会在在同一个网络中的另一个<code>replica</code>上面重新执行<code>map task</code>. 这样在执行一次大规模的<code>MapReduce</code>操作时, 大部分<code>input file</code>的读操作都是在本地进行, 没有网路带宽资源的消耗.</p><h3><a name='header-n54' class='md-header-anchor '></a><code>Task Granularity</code>任务粒度 </h3><p>将<code>map</code>分割为M块, 将<code>reduce</code>分割为R块. 理想情况下<code>M+R&gt;N</code>, N为<code>Worker</code>的数量. 每个<code>Worker</code>执行许多不同的任务可以提高动态负载均衡, 并且可以加速出错恢复.</p><p><code>Master</code>有<code>O(M+R)</code>种调度, 这样必须在内存中存储<code>O(M*R)</code>种状态. 通常M的数量为将<code>input file</code>分割为16MB-64MB块的数量,  R的数量为期望使用的<code>Worker</code>数量的2~5倍.</p><h2><a name='header-n58' class='md-header-anchor '></a>Lab实验</h2><h3><a name='header-n59' class='md-header-anchor '></a>lab <code>mapreduce</code> 分析</h3><h4><a name='header-n60' class='md-header-anchor '></a><code>Master</code></h4><p>存储了所有<code>Master</code>需要保存的信息:</p><ul><li>互斥量<code>sync.Mutex</code>: 对于有共享的数据结构进行并发控制, 即为<code>workers[]</code> 实现线程安全</li><li>条件变量 <code>sync.Cond</code>: 使用了典型的生产者消费者模型, 当有新的<code>worker</code>被注册到<code>master</code>中去时, <code>sync.Cond</code>会调用<code>boardcast</code>去唤醒所有等待该条件变量的goroutine.</li><li>doneChannel: 无缓冲<code>channel</code>, 通常可以用来进行线程同步.</li><li>shutdownChannel</li></ul><h4><a name='header-n71' class='md-header-anchor '></a><code>Master.Register</code></h4><p>注册函数. 使用互斥量作为并发控制, 将注册的<code>worker</code>添加到<code>workers[]</code>中. 通过条件变量, 唤醒<code>forwardRegistrations</code>, 即告知有新的<code>worker</code>添加.</p><h4><a name='header-n73' class='md-header-anchor '></a><code>Master.forwardRegistrations</code></h4><p>注册信息转寄函数, 典型的互斥量与信号量配合使用的方法, 当对信号量进行操作时, (唤醒和等待时, 释放当前的线程的锁, 然后切换线程). 该函数获取<code>master</code>中最新添加的<code>worker</code>, 并将该<code>worker</code>添加到一个特定的<code>channel</code>中(非阻塞), <code>schedule</code>函数通过<code>channel</code>读取<code>worker</code>的相关信息, 并消费.</p><p>该函数是一个<code>helper function</code>, <code>helper function</code>是其他函数计算的一部分, 或者说与其他函数的计算流程有关, 通常用来提高程序的可读性. 通过函数的命名可以看出所做事情和与其他函数的关联.</p><h4><a name='header-n76' class='md-header-anchor '></a><code>Master.run</code></h4><p>该函数在给定一定数量的<code>mapper</code>和<code>reducer</code>上面执行<code>mapreduce</code>任务.</p><ul><li><ol start='' ><li>根据给定数量的<code>mapper</code>, 将<code>input files</code>切分为若干部分.</li></ol></li><li><ol start='2' ><li>在可用或者空闲的<code>worker</code>上面调度任务.</li></ol></li><li><ol start='3' ><li>当所有的<code>mapper</code>任务结束, 就开始执行<code>reducer</code>的任务.</li></ol></li><li><ol start='4' ><li>当所有的<code>task</code>都结束时, <code>reducer</code>的结果将会被聚合</li></ol></li></ul><p>该函数, 接收一个<code>schuedule func(phase jobPhase)</code> 类型的调度函数, 用来实际执行特定的<code>mapper</code>或者<code>reducer</code>的任务.</p><p>该函数, 接收一个<code>finish func()</code>类型的函数, 用来处理调度完成之后的事项.</p><h4><a name='header-n97' class='md-header-anchor '></a><code>Worker</code></h4><p>存储了所有与<code>Worker</code>相关的一些状态信息</p><ul><li>互斥量<code>sync.Mutex</code>: 对于共享的数据进行并发控制保证安全性.</li><li>Map/Reduce: 函数类型</li></ul><h4><a name='header-n104' class='md-header-anchor '></a><code>Worker.DoTask</code></h4><p>该函数由<code>Master</code>调用, 当有一个新的<code>task</code>被<code>scheduled</code>时.</p><ul><li>使用<code>mutex</code>锁机制, 将<code>worker</code>的<code>concurrent</code>变量+1.</li><li>执行<code>Map</code>或<code>Reduce</code>操作</li><li>使用<code>mutex</code>锁机制, 将<code>worker</code>的<code>concurrent</code>变量-1.</li></ul><h4><a name='header-n113' class='md-header-anchor '></a><code>Worker.register</code></h4><p>该函数告诉<code>Master</code>当前<code>Worker</code>存在并且可以调用. 该函数内部调用了<code>RPC</code>, 服务.</p><h4><a name='header-n115' class='md-header-anchor '></a><code>Worker.RunWorker</code></h4><p>该函数设置<code>Worker</code>与<code>Master</code>的连接, 并且将该<code>Worker</code>的地址还有其他信息注册到<code>Master</code>中, 等待<code>task</code>的调度.</p><h3><a name='header-n118' class='md-header-anchor '></a>part1: <code>Map/Reduce</code> input and output</h3><p>主要编写两个函数, <code>doMap</code>和<code>doReduce</code>. </p><h4><a name='header-n120' class='md-header-anchor '></a><code>doMap</code>函数</h4><p>该函数用来管理一个<code>map</code>任务: 读取<code>input files</code>中的一个文件, 对于读取的内容执行用户定义的<code>mapF</code>, 并且将这个内容切分成<code>nReduce</code>个中间文件.</p><h4><a name='header-n123' class='md-header-anchor '></a><code>doReduce</code></h4><p>该函数用来管理一个<code>reduce</code>任务: 读取中间文件, <code>key/value</code> pairs. 先对于中间文件中的<code>key/value</code>进行排序, 然后再调用用户定义的<code>reduceF</code>, 将结果输出到磁盘上.</p><h3><a name='header-n125' class='md-header-anchor '></a>part2: <code>Single-worker</code> word count</h3><p>主要编写<code>mapF</code>和<code>reduceF</code>, 具体可以参考<code>mapreduce</code>的paper实现.</p><h3><a name='header-n127' class='md-header-anchor '></a>part3:  Distributing MapReduce tasks</h3><p>实现一个并行<code>worker</code>线程的<code>MapReduce</code>通过<code>rpc</code>来进行通信. 注意对于<code>worker</code>的调度的方法, 可以通过实现线程安全的队列来实现, 即使用经典的<code>Mutex/Cond</code>模型. 或者使用<code>Golang Channel</code>来实现调度.</p><h3><a name='header-n129' class='md-header-anchor '></a>part4: Handing worker failures</h3><p>实现<code>master</code>处理<code>failed worker</code>的功能. 由于<code>worker</code>没有持久的状态, 如果一个<code>worker</code>失败了, 则<code>master</code>将会通过<code>RPC</code>重新将失败的任务赋给其他的<code>worker</code>. </p><p><code>worker</code>失败最主要有如下两种状态:</p><ul><li><code>worker</code>已经执行了任务,但是<code>reply</code>丢失</li><li><code>worker</code>正在执行任务, 但是rpc超时.</li></ul><p>简单的来说就是实现一个错误重试机制.</p><h3><a name='header-n138' class='md-header-anchor '></a>part5: Inverted index generation</h3><p>通过编写<code>Map</code>和<code>Reduce</code>函数, 来实现构造一个倒排索引. 倒排索引被广泛的运用在文档搜索上面.</p><p>主要编写两个函数:</p><ul><li><code>mapFunction</code>: 将文档中的每个单词构造 <code>&lt;word, document ID&gt;</code>的kv对.</li><li><code>reduceFunction</code>: 接收所有构造的<code>&lt;word, document ID&gt;</code>的kv对, 并根据<code>document ID</code>进行排序,构造<code>&lt;word, list(document ID)&gt;</code>的对. </li></ul><h2><a name='header-n146' class='md-header-anchor '></a>总结</h2><p>lab1 花了挺多时间, 熟悉学习了golang的代码设计, 以及rpc相关知识, 不得不说MapReduce论文的思想确实十分伟大. lab1的实现简单但是需要思考很多问题, 收货颇丰!</p><h2><a name='header-n148' class='md-header-anchor '></a>Reference</h2><p><a href='http://airekans.github.io/cloud-computing/2014/01/25/mapreduce-intro'>MapReduce简介</a></p><p><a href='https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf'>google MapReduce papers</a></p><p><a href='https://parthdesai.me/articles/2016/05/20/go-rpc-server/'>go rpc教程</a></p><p><a href='https://blog.golang.org/pipelines'>go pipeline</a></p></div>
</body>
</html>